--- Project Context for ejd_cards ---
--- Generated on: 2025-06-15T00:30:37.585056 ---
--- Root Directory: c:\Users\user\Documents\FlutterProjects\ejd_cards ---


--- START FILE: .gitignore ---
# Miscellaneous
*.class
*.lock
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/
modules.xml
out/

# Visual Studio Code related
.vscode/

# Flutter/Dart related
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.packages
.pub-cache/
.pub/
/build/
/ios/Pods/
/ios/.symlinks/
/ios/Flutter/App.framework
/ios/Flutter/Flutter.framework
/ios/Flutter/Generated.xcconfig
/ios/Flutter/flutter_export_environment.sh
/ios/Runner/GeneratedPluginRegistrant.*
/ios/Runner.xcodeproj/project.xcworkspace/
/ios/Runner.xcodeproj/xcshareddata/
/ios/Runner.xcworkspace/contents.xcworkspacedata
/android/.gradle/
/android/captures/
/android/gradle
/android/gradle.properties # If it contains sensitive information
/android/gradlew
/android/gradlew.bat
/android/key.properties # Contains signing key passwords
/android/local.properties
/android/app/src/main/res/values/google_maps_api.xml # API keys
*.keystore # Android signing keys
*.jks # Java KeyStore

# Windows related
# Typically files generated by Visual Studio or Windows build processes
AppPackages/
BundleArtifacts/
PackageUploads/
x64/
x86/
ARM64/
ARM/
Generated Files/
flutter_windows.dll
vc_redist.*.exe
# NuGet Packages
packages/

# Linux related
# Typically generated build artifacts

# macOS related
# Typically generated build artifacts
*.xcodeproj/project.xcworkspace/xcshareddata/IDETemplateMacros.plist

# Web related
# Typically generated build artifacts
# /web/build/ # Already covered by /build/  
--- END FILE: .gitignore ---


--- START FILE: analysis_options.yaml ---
include: package:flutter_lints/flutter.yaml

analyzer:
  # You can enable stricter checks later if you wish:
  # strong-mode:
  #   implicit-casts: false
  #   implicit-dynamic: false
  errors:
    # You can customize severity of specific lint rules here if needed
    # e.g., make some warnings into errors
    # missing_required_param: error
    prefer_const_constructors: warning # Good to enable

linter:
  rules:
    # Common good practices, uncomment and add more as we go or as you learn
    prefer_const_constructors: true
    prefer_final_fields: true
    use_key_in_widget_constructors: true
    # avoid_print: true # Uncomment this when closer to release, to avoid debug prints
    # package_prefixed_library_names: true
    # slash_for_doc_comments: true
    # type_annotate_public_apis: true
    # unawaited_futures: true
    # directives_ordering: true # Helps keep imports organized
    # prefer_single_quotes: true # Or false if you prefer double
    # avoid_relative_lib_imports: true # Good for larger projects
--- END FILE: analysis_options.yaml ---


--- START FILE: generate-context.dart ---
// generate_context.dart
import 'dart:io';
import 'package:path/path.dart' as p;

// --- Configuration ---
const String outputFile = 'project_context.txt';
final String rootDir = Directory.current.path;

// Directories to completely ignore. This is the most effective way to cut tokens.
final Set<String> excludeDirs = {
  '.git',
  '.dart_tool',
  '.idea',
  'build',
  'ios',
  'android',
  'linux',
  'macos',
  'windows',
  'web',
  '.fvm', // In case you use Flutter Version Management
};

// Specific file names to exclude.
final Set<String> excludeFiles = {
  'pubspec.lock',
  'generate_context.dart', // Exclude this script itself
  'generate-tree.cjs',     // Exclude the other script
  'project-tree.txt',
  outputFile,
  '.flutter-plugins',
  '.flutter-plugins-dependencies',
  '.metadata',
  'README.md',
};

// File extensions to exclude.
final Set<String> excludeExtensions = {
  '.png', '.jpg', '.jpeg', '.gif', '.webp', '.ico', '.svg',
  '.woff', '.woff2', '.ttf', '.eot',
  '.db', '.sqlite', '.sqlite3',
  '.DS_Store',
  '.iml',
  '.packages',
};
// --- End Configuration ---

Future<void> main() async {
  final outputFileSink = File(outputFile).openWrite();
  int processedCount = 0;
  int excludedCount = 0;

  print('--- Starting Context Generation Script ---');
  print('Root directory: $rootDir');
  print('Output file: $outputFile');

  outputFileSink.writeln('--- Project Context for ${p.basename(rootDir)} ---');
  outputFileSink.writeln('--- Generated on: ${DateTime.now().toIso8601String()} ---');
  outputFileSink.writeln('--- Root Directory: $rootDir ---\n\n');

  final entities = Directory(rootDir).listSync(recursive: true, followLinks: false);

  entities.sort((a, b) {
    if (a is Directory && b is File) return -1;
    if (a is File && b is Directory) return 1;
    return a.path.compareTo(b.path);
  });

  for (final entity in entities) {
    final relativePath = p.relative(entity.path, from: rootDir);
    final pathParts = p.split(relativePath);

    if (pathParts.any((part) => excludeDirs.contains(part))) {
      excludedCount++;
      continue;
    }

    if (entity is File) {
      final fileName = p.basename(entity.path);
      final fileExt = p.extension(fileName).toLowerCase();

      if (excludeFiles.contains(fileName) || excludeExtensions.contains(fileExt)) {
        excludedCount++;
        continue;
      }

      print('Processing: $relativePath');
      processedCount++;
      
      outputFileSink.writeln('--- START FILE: $relativePath ---');
      try {
        final content = await entity.readAsString();
        if (content.isEmpty) {
          outputFileSink.writeln('[EMPTY FILE]');
        } else {
          outputFileSink.writeln(content);
        }
      } catch (e) {
        outputFileSink.writeln('[ERROR: Could not read file as text - likely a binary file]');
      }
      outputFileSink.writeln('--- END FILE: $relativePath ---\n\n');
    }
  }

  await outputFileSink.close();
  print('--- Script Finished ---');
  print('Processed $processedCount files.');
  print('Excluded $excludedCount files/directories.');
  print('Output saved to: $outputFile');
}
--- END FILE: generate-context.dart ---


--- START FILE: lib\core\models\card_model.dart ---
// lib/core/models/card_model.dart

class CardModel {
  final String id;
  String frontText;
  String backText;
  String? explanation;
  bool needsReview;

  CardModel({
    required this.id,
    required this.frontText,
    required this.backText,
    this.explanation,
    this.needsReview = false,
  });

  // Creates a CardModel instance from a map (e.g., when loading from JSON)
  factory CardModel.fromMap(Map<String, dynamic> map) {
    return CardModel(
      id: map['id'] as String,
      frontText: map['frontText'] as String,
      backText: map['backText'] as String,
      explanation: map['explanation'] as String?,
      // Handle old data that might not have this field by defaulting to false
      needsReview: map['needsReview'] as bool? ?? false,
    );
  }

  // Converts a CardModel instance to a map (e.g., for saving to JSON)
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'frontText': frontText,
      'backText': backText,
      'explanation': explanation,
      'needsReview': needsReview,
    };
  }

  @override
  String toString() {
    return 'CardModel(id: $id, front: "$frontText", back: "$backText", explanation: "$explanation", needsReview: $needsReview)';
  }
}
--- END FILE: lib\core\models\card_model.dart ---


--- START FILE: lib\core\models\deck_model.dart ---
// lib/core/models/deck_model.dart

import 'card_model.dart';

class DeckModel {
  final String id;
  String title;
  List<CardModel> cards;
  DateTime createdAt;
  DateTime? lastStudiedAt;
  int? lastReviewedCardIndex;

  // Autoplay settings specific to this deck
  int? customFrontTimeSeconds;
  int? customBackTimeSeconds;

  DeckModel({
    required this.id,
    required this.title,
    List<CardModel>? cards,
    DateTime? createdAt,
    this.lastStudiedAt,
    this.lastReviewedCardIndex,
    this.customFrontTimeSeconds,
    this.customBackTimeSeconds,
  })  : cards = cards ?? [],
        createdAt = createdAt ?? DateTime.now();

  // Helper getter for card count
  int get cardCount => cards.length;

  // Creates a DeckModel instance from a map (e.g., when loading from JSON)
  factory DeckModel.fromMap(Map<String, dynamic> map) {
    return DeckModel(
      id: map['id'] as String,
      title: map['title'] as String,
      cards: (map['cards'] as List<dynamic>? ?? [])
          .map((cardMap) => CardModel.fromMap(cardMap as Map<String, dynamic>))
          .toList(),
      createdAt: DateTime.parse(map['createdAt'] as String),
      lastStudiedAt: map['lastStudiedAt'] != null ? DateTime.parse(map['lastStudiedAt'] as String) : null,
      lastReviewedCardIndex: map['lastReviewedCardIndex'] as int?,
      customFrontTimeSeconds: map['customFrontTimeSeconds'] as int?,
      customBackTimeSeconds: map['customBackTimeSeconds'] as int?,
    );
  }

  // Converts a DeckModel instance to a map (e.g., for saving to JSON)
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'title': title,
      'cards': cards.map((card) => card.toMap()).toList(),
      'createdAt': createdAt.toIso8601String(),
      'lastStudiedAt': lastStudiedAt?.toIso8601String(),
      'lastReviewedCardIndex': lastReviewedCardIndex,
      'customFrontTimeSeconds': customFrontTimeSeconds,
      'customBackTimeSeconds': customBackTimeSeconds,
    };
  }
}
--- END FILE: lib\core\models\deck_model.dart ---


--- START FILE: lib\core\services\deck_persistence_service.dart ---
// lib/core/services/deck_persistence_service.dart

import 'dart:convert';
import 'dart:io';
import 'package:flutter/foundation.dart' show kIsWeb; // Important for checking platform
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/deck_model.dart';

class DeckPersistenceService {
  // --- For Web ---
  static const String _webStorageKey = 'all_decks_storage';

  // --- For Mobile/Desktop ---
  static const String _decksFolderName = "flashcard_decks";

  // Gets the directory where decks are stored, creating it if it doesn't exist.
  // This method is ONLY for non-web platforms.
  Future<Directory> _getDecksDirectory() async {
    final appDocDir = await getApplicationDocumentsDirectory();
    final decksDir = Directory('${appDocDir.path}/$_decksFolderName');
    if (!await decksDir.exists()) {
      await decksDir.create(recursive: true);
    }
    return decksDir;
  }

  // Gets the full file path for a given deck ID.
  Future<String> _getFilePath(String deckId) async {
    final dir = await _getDecksDirectory();
    return '${dir.path}/$deckId.json';
  }

  // --- Platform-Aware Methods ---

  Future<void> saveDeck(DeckModel deck) async {
    if (kIsWeb) {
      // WEB: Load all decks, add/update this one, save all back.
      final decks = await loadDecks();
      final index = decks.indexWhere((d) => d.id == deck.id);
      if (index != -1) {
        decks[index] = deck; // Update existing
      } else {
        decks.add(deck); // Add new
      }
      await _saveAllDecksForWeb(decks);
    } else {
      // MOBILE/DESKTOP: Save to individual file.
      try {
        final filePath = await _getFilePath(deck.id);
        final file = File(filePath);
        final jsonString = const JsonEncoder.withIndent('  ').convert(deck.toMap());
        await file.writeAsString(jsonString);
        print('Deck saved: ${deck.title} to $filePath');
      } catch (e) {
        print('Error saving deck ${deck.id}: $e');
      }
    }
  }

  Future<List<DeckModel>> loadDecks() async {
    if (kIsWeb) {
      // WEB: Load the single JSON string from shared_preferences.
      try {
        final prefs = await SharedPreferences.getInstance();
        final String? allDecksJson = prefs.getString(_webStorageKey);
        if (allDecksJson == null) {
          return [];
        }
        final List<dynamic> deckList = jsonDecode(allDecksJson);
        final decks = deckList.map((map) => DeckModel.fromMap(map)).toList();
        print('Loaded ${decks.length} decks from web storage.');
        return decks;
      } catch (e) {
        print('Error loading decks from web storage: $e');
        return [];
      }
    } else {
      // MOBILE/DESKTOP: Load all individual files.
      try {
        final dir = await _getDecksDirectory();
        final List<DeckModel> decks = [];
        final List<FileSystemEntity> entities = await dir.list().toList();

        for (FileSystemEntity entity in entities) {
          if (entity is File && entity.path.endsWith('.json')) {
            try {
              final jsonString = await entity.readAsString();
              final Map<String, dynamic> jsonMap = jsonDecode(jsonString);
              decks.add(DeckModel.fromMap(jsonMap));
            } catch (e) {
              print('Error reading or parsing deck file ${entity.path}: $e');
            }
          }
        }
        print('Loaded ${decks.length} decks from file system.');
        return decks;
      } catch (e) {
        print('Error loading decks directory: $e');
        return [];
      }
    }
  }

  Future<void> deleteDeck(String deckId) async {
    if (kIsWeb) {
      // WEB: Load all, remove one, save all back.
      final decks = await loadDecks();
      decks.removeWhere((deck) => deck.id == deckId);
      await _saveAllDecksForWeb(decks);
    } else {
      // MOBILE/DESKTOP: Delete the individual file.
      try {
        final filePath = await _getFilePath(deckId);
        final file = File(filePath);
        if (await file.exists()) {
          await file.delete();
          print('Deck file deleted: $deckId.json');
        }
      } catch (e) {
        print('Error deleting deck file $deckId.json: $e');
      }
    }
  }

  Future<void> deleteAllDecks() async {
    if (kIsWeb) {
      // WEB: Just remove the key from shared_preferences.
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_webStorageKey);
      print('All web storage decks deleted.');
    } else {
      // MOBILE/DESKTOP: Delete the whole directory.
      try {
        final dir = await _getDecksDirectory();
        if (await dir.exists()) {
          await dir.delete(recursive: true);
          print('All deck files deleted.');
          await _getDecksDirectory();
        }
      } catch (e) {
        print('Error deleting all decks: $e');
      }
    }
  }

  // Helper method specifically for saving all decks on the web
  Future<void> _saveAllDecksForWeb(List<DeckModel> decks) async {
    final prefs = await SharedPreferences.getInstance();
    final List<Map<String, dynamic>> deckListMap = decks.map((deck) => deck.toMap()).toList();
    final allDecksJson = jsonEncode(deckListMap);
    await prefs.setString(_webStorageKey, allDecksJson);
    print('Saved ${decks.length} decks to web storage.');
  }
}
--- END FILE: lib\core\services\deck_persistence_service.dart ---


--- START FILE: lib\core\services\settings_service.dart ---
// lib/core/services/settings_service.dart

import 'package:shared_preferences/shared_preferences.dart';
import '../../main.dart'; // Import to get the AppThemeMode enum

class SettingsService {
  // Define keys for shared_preferences
  static const String _keyThemeMode = 'appThemeMode'; // Using a more specific key
  static const String _keyDefaultFrontTime = 'defaultFrontTime';
  static const String _keyDefaultBackTime = 'defaultBackTime';
  static const String _keyAutoplayShuffle = 'autoplayShuffle';
  static const String _keyAutoplayLoop = 'autoplayLoop';

  // Define default values if no setting is stored
  static const int defaultFrontSeconds = 5;
  static const int defaultBackSeconds = 7;
  static const bool defaultShuffle = false;
  static const bool defaultLoop = false;

  // Helper to get the SharedPreferences instance
  Future<SharedPreferences> _getPrefs() async {
    return await SharedPreferences.getInstance();
  }

  // --- Theme Mode ---
  Future<void> setThemeMode(AppThemeMode mode) async {
    final prefs = await _getPrefs();
    await prefs.setString(_keyThemeMode, mode.name);
  }

  Future<AppThemeMode> getThemeMode() async {
    final prefs = await _getPrefs();
    final themeString = prefs.getString(_keyThemeMode);
    // Find the AppThemeMode that matches the stored string, or default to system
    return AppThemeMode.values.firstWhere(
      (e) => e.name == themeString,
      orElse: () => AppThemeMode.system,
    );
  }

  // --- Default Front Time ---
  Future<void> setDefaultFrontTime(int seconds) async {
    final prefs = await _getPrefs();
    await prefs.setInt(_keyDefaultFrontTime, seconds);
  }

  Future<int> getDefaultFrontTime() async {
    final prefs = await _getPrefs();
    return prefs.getInt(_keyDefaultFrontTime) ?? defaultFrontSeconds;
  }

  // --- Default Back Time ---
  Future<void> setDefaultBackTime(int seconds) async {
    final prefs = await _getPrefs();
    await prefs.setInt(_keyDefaultBackTime, seconds);
  }

  Future<int> getDefaultBackTime() async {
    final prefs = await _getPrefs();
    return prefs.getInt(_keyDefaultBackTime) ?? defaultBackSeconds;
  }

  // --- Autoplay Shuffle ---
  Future<void> setAutoplayShuffle(bool shuffle) async {
    final prefs = await _getPrefs();
    await prefs.setBool(_keyAutoplayShuffle, shuffle);
  }

  Future<bool> getAutoplayShuffle() async {
    final prefs = await _getPrefs();
    return prefs.getBool(_keyAutoplayShuffle) ?? defaultShuffle;
  }

  // --- Autoplay Loop ---
  Future<void> setAutoplayLoop(bool loop) async {
    final prefs = await _getPrefs();
    await prefs.setBool(_keyAutoplayLoop, loop);
  }

  Future<bool> getAutoplayLoop() async {
    final prefs = await _getPrefs();
    return prefs.getBool(_keyAutoplayLoop) ?? defaultLoop;
  }
}
--- END FILE: lib\core\services\settings_service.dart ---


--- START FILE: lib\core\theme\app_theme.dart ---
// lib/core/theme/app_theme.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class AppTheme {
  static final _baseTextTheme = GoogleFonts.poppinsTextTheme(const TextTheme()).copyWith(
    displaySmall: GoogleFonts.poppins(fontWeight: FontWeight.w600),
    headlineMedium: GoogleFonts.poppins(fontWeight: FontWeight.w600),
    titleLarge: GoogleFonts.poppins(fontWeight: FontWeight.bold),
  );

  static final lightTheme = ThemeData(
    useMaterial3: true,
    brightness: Brightness.light,
    colorScheme: ColorScheme.fromSeed(
      seedColor: const Color(0xFF6A5AE0),
      brightness: Brightness.light,
      primary: const Color(0xFF6A5AE0),
      surface: const Color(0xFFFFFFFF),
      background: const Color(0xFFF6F6F9),
    ),
    textTheme: _baseTextTheme.apply(
      bodyColor: Colors.black87,
      displayColor: Colors.black,
    ),
    scaffoldBackgroundColor: const Color(0xFFF6F6F9),
  );

  static final darkTheme = ThemeData(
    useMaterial3: true,
    brightness: Brightness.dark,
    colorScheme: ColorScheme.fromSeed(
      seedColor: const Color(0xFF7B61FF),
      brightness: Brightness.dark,
      primary: const Color(0xFF7B61FF),
      surface: const Color(0xFF2D2D3A), // Dark Grey Card background
      background: const Color(0xFF1F1F29), // Dark Grey App background
    ),
    textTheme: _baseTextTheme.apply(
      bodyColor: Colors.white70,
      displayColor: Colors.white,
    ),
    scaffoldBackgroundColor: const Color(0xFF1F1F29),
  );

  static final amoledTheme = ThemeData(
    useMaterial3: true,
    brightness: Brightness.dark,
    colorScheme: ColorScheme.fromSeed(
      seedColor: const Color(0xFF7B61FF),
      brightness: Brightness.dark,
      primary: const Color(0xFF7B61FF),
      surface: const Color(0xFF121212), // Slightly off-black for cards
      background: const Color(0xFF000000), // True black for background
    ),
    textTheme: _baseTextTheme.apply(
      bodyColor: Colors.white70,
      displayColor: Colors.white,
    ),
    scaffoldBackgroundColor: const Color(0xFF000000),
  );
}
--- END FILE: lib\core\theme\app_theme.dart ---


--- START FILE: lib\core\widgets\flip_card_widget.dart ---
// lib/core/widgets/flip_card_widget.dart

import 'dart:math';
import 'package:flutter/material.dart';

// A controller to programmatically trigger the flip action from the parent widget.
class FlipCardController {
  _FlipCardWidgetState? _state;

  void _attach(_FlipCardWidgetState state) {
    _state = state;
  }

  void flip() {
    _state?.flip();
  }

  void reset() {
    _state?.reset();
  }
}

class FlipCardWidget extends StatefulWidget {
  final Widget front;
  final Widget back;
  final FlipCardController controller;

  const FlipCardWidget({
    super.key,
    required this.front,
    required this.back,
    required this.controller,
  });

  @override
  State<FlipCardWidget> createState() => _FlipCardWidgetState();
}

class _FlipCardWidgetState extends State<FlipCardWidget> with SingleTickerProviderStateMixin {
  late AnimationController _animationController;
  late Animation<double> _animation;
  bool _isFrontVisible = true;

  @override
  void initState() {
    super.initState();
    widget.controller._attach(this);

    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 500),
    );

    _animation = Tween<double>(begin: 0, end: 1).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeInOut),
    );

    _animationController.addListener(() {
      if (mounted) {
        setState(() {});
      }
    });
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  void flip() {
    if (_animationController.isAnimating) return;
    if (_isFrontVisible) {
      _animationController.forward();
    } else {
      _animationController.reverse();
    }
    _isFrontVisible = !_isFrontVisible;
  }

  void reset() {
    // Reset the card to the front without an animation
    if (!_isFrontVisible) {
      _animationController.value = 0; // Directly set animation value to start
      _isFrontVisible = true;
    }
  }

  @override
  Widget build(BuildContext context) {
    final angle = _animation.value * pi;
    final transform = Matrix4.identity()
      ..setEntry(3, 2, 0.001) // This adds the 3D perspective effect
      ..rotateY(angle);

    return Transform(
      transform: transform,
      alignment: Alignment.center,
      // If the card is past 90 degrees, show the back side.
      // We also need to apply a transform to the back to "un-mirror" it.
      child: _isAnglePastHalfway(angle)
          ? Transform(
              transform: Matrix4.identity()..rotateY(pi), // Pre-flip the back
              alignment: Alignment.center,
              child: _buildCard(widget.back),
            )
          : _buildCard(widget.front),
    );
  }

  bool _isAnglePastHalfway(double angle) {
    // The angle is in radians, pi is 180 degrees.
    // We check if it's past 90 degrees (pi / 2).
    return angle >= (pi / 2);
  }

  // Helper to build the card's visual structure
  Widget _buildCard(Widget child) {
    return Card(
      elevation: 8.0,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20.0)),
      child: Container(
        padding: const EdgeInsets.all(24.0),
        width: double.infinity,
        height: double.infinity,
        child: Center(
          child: SingleChildScrollView(
            child: child,
          ),
        ),
      ),
    );
  }
}
--- END FILE: lib\core\widgets\flip_card_widget.dart ---


--- START FILE: lib\features\deck_list\screens\deck_list_screen.dart ---
// lib/features/deck_list/screens/deck_list_screen.dart

import 'dart:typed_data';
import 'package:ejd_cards/features/deck_list/widgets/deck_list_item.dart';
import 'package:ejd_cards/features/deck_management/screens/deck_edit_screen.dart';
import 'package:ejd_cards/features/deck_management/services/deck_exporter_service.dart';
import 'package:ejd_cards/features/deck_management/services/deck_importer_service.dart';
import 'package:ejd_cards/features/settings/screens/settings_screen.dart';
import 'package:ejd_cards/features/study_mode/screens/autoplay_screen.dart';
import 'package:ejd_cards/features/study_mode/screens/manual_study_screen.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:iconsax_flutter/iconsax_flutter.dart';
import '../../../core/models/deck_model.dart';
import '../../../core/services/deck_persistence_service.dart';

class DeckListScreen extends StatefulWidget {
  const DeckListScreen({super.key});

  @override
  State<DeckListScreen> createState() => _DeckListScreenState();
}

class _DeckListScreenState extends State<DeckListScreen> {
  List<DeckModel> _decks = [];
  final DeckPersistenceService _persistenceService = DeckPersistenceService();
  final DeckImporterService _importerService = DeckImporterService();
  final DeckExporterService _exporterService = DeckExporterService();
  bool _isLoading = true;
  bool _isImporting = false;

  @override
  void initState() {
    super.initState();
    _loadPersistedDecks();
  }

  Future<void> _loadPersistedDecks() async {
    if (!mounted) return;
    setState(() {
      _isLoading = true;
    });

    final loadedDecks = await _persistenceService.loadDecks();

    if (mounted) {
      setState(() {
        _decks = loadedDecks;
        _isLoading = false;
      });
    }
  }

  Future<void> _deleteDeckAndPersist(String deckId) async {
    final deckToRemoveIndex = _decks.indexWhere((d) => d.id == deckId);
    if (deckToRemoveIndex == -1) return;

    final deckTitle = _decks[deckToRemoveIndex].title;
    if (mounted) {
      setState(() {
        _decks.removeAt(deckToRemoveIndex);
      });
    }

    await _persistenceService.deleteDeck(deckId);

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Deck "$deckTitle" deleted.')),
      );
    }
  }

  void _showDeleteConfirmationDialog(DeckModel deck) {
    showDialog(
      context: context,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: const Text('Delete Deck'),
          content: Text('Are you sure you want to delete the deck "${deck.title}"? This action cannot be undone.'),
          actions: <Widget>[
            TextButton(
              child: const Text('Cancel'),
              onPressed: () => Navigator.of(dialogContext).pop(),
            ),
            TextButton(
              style: TextButton.styleFrom(foregroundColor: Colors.red),
              child: const Text('Delete'),
              onPressed: () {
                Navigator.of(dialogContext).pop();
                _deleteDeckAndPersist(deck.id);
              },
            ),
          ],
        );
      },
    );
  }

  Future<void> _pickAndImportDeck() async {
    if (!mounted) return;
    setState(() {
      _isImporting = true;
    });

    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['json'],
      );

      if (result != null && result.files.single.bytes != null) {
        Uint8List fileBytes = result.files.single.bytes!;
        _processImport(await _importerService.importDeckFromFile(fileBytes));
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('File picking failed: ${e.toString()}')),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isImporting = false;
        });
      }
    }
  }

  void _showImportFromTextDialog() {
    final textController = TextEditingController();
    final formKey = GlobalKey<FormState>();

    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Import from Text'),
          content: Form(
            key: formKey,
            child: TextFormField(
              controller: textController,
              maxLines: 10,
              decoration: const InputDecoration(
                labelText: 'Paste JSON here',
                hintText: 'Paste the JSON content from your LLM...',
                border: OutlineInputBorder(),
              ),
              validator: (value) => (value == null || value.trim().isEmpty) ? 'Pasted text cannot be empty.' : null,
            ),
          ),
          actions: [
            TextButton(
              child: const Text('Cancel'),
              onPressed: () => Navigator.of(context).pop(),
            ),
            ElevatedButton(
              child: const Text('Import'),
              onPressed: () async {
                if (formKey.currentState!.validate()) {
                  final pastedText = textController.text;
                  Navigator.of(context).pop();
                  _processImport(await _importerService.importDeckFromString(pastedText));
                }
              },
            ),
          ],
        );
      },
    );
  }

  Future<void> _processImport(ParseResult parseResult) async {
    if (!mounted) return;

    if (parseResult.hasError) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Import Error: ${parseResult.error}'),
          backgroundColor: Colors.redAccent,
        ),
      );
    } else if (parseResult.deck != null) {
      bool deckExists = _decks.any((deck) => deck.title.toLowerCase() == parseResult.deck!.title.toLowerCase());
      if (deckExists) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('A deck with the title "${parseResult.deck!.title}" already exists.')),
        );
      } else {
        await _persistenceService.saveDeck(parseResult.deck!);
        await _loadPersistedDecks(); // Reload from storage to ensure consistency and trigger animation
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Deck "${parseResult.deck!.title}" imported successfully!'),
              backgroundColor: Colors.green,
            ),
          );
        }
      }
    }
  }

  void _handleManualStudyStart(DeckModel deck) {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => ManualStudyScreen(deck: deck)),
    );
  }

  void _handleAutoplayStart(DeckModel deck) {
    final int resumeIndex = deck.lastReviewedCardIndex ?? 0;
    if (resumeIndex > 0 && deck.cards.length > resumeIndex) {
      showDialog(
        context: context,
        builder: (BuildContext dialogContext) {
          return AlertDialog(
            title: const Text('Resume Study?'),
            content: Text('You left off on card ${resumeIndex + 1}. Would you like to resume or start over?'),
            actions: <Widget>[
              TextButton(
                child: const Text('Start Over'),
                onPressed: () {
                  Navigator.of(dialogContext).pop();
                  _navigateToAutoplay(deck, startIndex: 0);
                },
              ),
              ElevatedButton(
                child: const Text('Resume'),
                onPressed: () {
                  Navigator.of(dialogContext).pop();
                  _navigateToAutoplay(deck, startIndex: resumeIndex);
                },
              ),
            ],
          );
        },
      );
    } else {
      _navigateToAutoplay(deck, startIndex: 0);
    }
  }

  Future<void> _navigateToAutoplay(DeckModel deck, {required int startIndex}) async {
    final result = await Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => AutoplayScreen(deck: deck, startIndex: startIndex),
      ),
    );
    if (result == true && mounted) {
      _loadPersistedDecks();
    }
  }

  Future<void> _handleDeckEdit(DeckModel deck) async {
    final result = await Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => DeckEditScreen(initialDeck: deck)),
    );
    if (result == true && mounted) {
      _loadPersistedDecks();
    }
  }

  Future<void> _handleDeckExport(DeckModel deck) async {
    final resultMessage = await _exporterService.exportDeck(deck);
    if (mounted && resultMessage != null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(resultMessage)),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      appBar: AppBar(
        title: const Text('My Decks'),
        centerTitle: true,
        elevation: 0,
        backgroundColor: theme.scaffoldBackgroundColor,
        actions: [
          IconButton(
            icon: const Icon(Iconsax.setting_2),
            tooltip: 'Settings',
            onPressed: () {
              Navigator.push(
                context,
                MaterialPageRoute(builder: (context) => const SettingsScreen()),
              );
            },
          ),
        ],
      ),
      body: _isLoading || _isImporting
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const CircularProgressIndicator(),
                  const SizedBox(height: 16),
                  Text(_isImporting ? "Importing deck..." : "Loading decks..."),
                ],
              ),
            )
          : _buildDeckList(),
      floatingActionButton: PopupMenuButton<String>(
        tooltip: 'Add Deck',
        onSelected: (String value) async {
          if (value == 'create_manual') {
            final result = await Navigator.push(
              context,
              MaterialPageRoute(builder: (context) => const DeckEditScreen()),
            );
            if (result == true && mounted) {
              _loadPersistedDecks();
            }
          } else if (value == 'import_file') {
            _pickAndImportDeck();
          } else if (value == 'import_text') {
            _showImportFromTextDialog();
          }
        },
        itemBuilder: (BuildContext context) => <PopupMenuEntry<String>>[
          const PopupMenuItem<String>(
            value: 'create_manual',
            child: ListTile(
              leading: Icon(Iconsax.edit),
              title: Text('Create Manually'),
            ),
          ),
          const PopupMenuItem<String>(
            value: 'import_file',
            child: ListTile(
              leading: Icon(Iconsax.document_upload),
              title: Text('Import from File'),
            ),
          ),
          const PopupMenuItem<String>(
            value: 'import_text',
            child: ListTile(
              leading: Icon(Iconsax.document_text),
              title: Text('Paste from Text'),
            ),
          ),
        ],
        child: Container(
          padding: const EdgeInsets.all(16.0),
          decoration: BoxDecoration(
            color: theme.colorScheme.primary,
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                color: theme.colorScheme.primary.withAlpha(77), // 30% of 255 is ~77
                blurRadius: 8.0,
                offset: const Offset(0, 4),
              ),
            ],
          ),
          child: const Icon(Iconsax.add, color: Colors.white, size: 28),
        ),
      ),
    );
  }

  Widget _buildDeckList() {
    if (_decks.isEmpty) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Icon(Iconsax.safe_home, size: 80.0, color: Colors.grey),
              const SizedBox(height: 24.0),
              Text('Your Bookshelf is Empty', style: Theme.of(context).textTheme.headlineSmall),
              const SizedBox(height: 12.0),
              Text(
                'Tap the "+" button to create a new deck or import one.',
                textAlign: TextAlign.center,
                style: Theme.of(context).textTheme.bodyLarge?.copyWith(color: Colors.grey[600]),
              ),
            ],
          ),
        ),
      );
    }

   return ListView.builder(
  padding: const EdgeInsets.only(bottom: 80),
  itemCount: _decks.length,
  itemBuilder: (context, index) {
    final deck = _decks[index];
    return DeckListItem(
      deck: deck,
      onStudy: () => _handleManualStudyStart(deck),
      onPlay: () => _handleAutoplayStart(deck),
      onEdit: () => _handleDeckEdit(deck),
      onDelete: () => _showDeleteConfirmationDialog(deck),
      onExport: () => _handleDeckExport(deck),
    )
        .animate()
        .fadeIn(
          duration: 400.ms,
          curve: Curves.easeOut,
          delay: (index * 75).ms, // Apply a staggered delay to each item
        )
        .slideY(
          begin: 0.2,
          end: 0,
          duration: 400.ms,
          curve: Curves.easeOut,
          delay: (index * 75).ms, // Apply the same delay
        );
  },
);
  }
}
--- END FILE: lib\features\deck_list\screens\deck_list_screen.dart ---


--- START FILE: lib\features\deck_list\widgets\deck_list_item.dart ---
// lib/features/deck_list/widgets/deck_list_item.dart

import 'package:flutter/material.dart';
import 'package:iconsax_flutter/iconsax_flutter.dart';
import '../../../core/models/deck_model.dart';

class DeckListItem extends StatelessWidget {
  final DeckModel deck;
  final VoidCallback onPlay;
  final VoidCallback onStudy;
  final VoidCallback onEdit;
  final VoidCallback onDelete;
  final VoidCallback onExport;

  const DeckListItem({
    super.key,
    required this.deck,
    required this.onPlay,
    required this.onStudy,
    required this.onEdit,
    required this.onDelete,
    required this.onExport,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final progress = (deck.cardCount > 0 && deck.lastReviewedCardIndex != null && deck.lastReviewedCardIndex! > 0)
        ? ((deck.lastReviewedCardIndex! + 1) / deck.cardCount)
        : 0.0;

    return GestureDetector(
      onTap: onStudy,
      child: Container(
        margin: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
        padding: const EdgeInsets.all(16.0),
        decoration: BoxDecoration(
          color: colorScheme.surface,
          borderRadius: BorderRadius.circular(16.0),
          boxShadow: [
            BoxShadow(
              color: colorScheme.shadow.withOpacity(0.05),
              blurRadius: 10,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  child: Text(
                    deck.title,
                    style: theme.textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: colorScheme.onSurface,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                PopupMenuButton<String>(
                  icon: Icon(Iconsax.more, color: colorScheme.onSurfaceVariant),
                  onSelected: (value) {
                    if (value == 'edit') onEdit();
                    if (value == 'export') onExport();
                    if (value == 'delete') onDelete();
                  },
                  itemBuilder: (BuildContext context) => <PopupMenuEntry<String>>[
                    const PopupMenuItem<String>(
                      value: 'edit',
                      child: ListTile(leading: Icon(Iconsax.edit), title: Text('Edit')),
                    ),
                    const PopupMenuItem<String>(
                      value: 'export',
                      child: ListTile(leading: Icon(Iconsax.export_3), title: Text('Export/Share')),
                    ),
                    const PopupMenuItem<String>(
                      value: 'delete',
                      child: ListTile(leading: Icon(Iconsax.trash, color: Colors.red), title: Text('Delete', style: TextStyle(color: Colors.red))),
                    ),
                  ],
                ),
              ],
            ),
            const SizedBox(height: 8),
            Text(
              '${deck.cardCount} card${deck.cardCount == 1 ? "" : "s"}',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Progress: ${(progress * 100).toStringAsFixed(0)}%',
                        style: theme.textTheme.labelSmall?.copyWith(
                          color: colorScheme.onSurfaceVariant,
                        ),
                      ),
                      const SizedBox(height: 4),
                      ClipRRect(
                        borderRadius: BorderRadius.circular(8),
                        child: LinearProgressIndicator(
                          value: progress > 1.0 ? 1.0 : progress, // Ensure value is not > 1
                          minHeight: 8,
                          backgroundColor: colorScheme.surfaceVariant,
                          valueColor: AlwaysStoppedAnimation<Color>(colorScheme.primary),
                        ),
                      ),
                    ],
                  ),
                ),
                const SizedBox(width: 16),
                ElevatedButton(
                  onPressed: deck.cardCount > 0 ? onPlay : null, // Disable play if no cards
                  style: ElevatedButton.styleFrom(
                    shape: const CircleBorder(),
                    padding: const EdgeInsets.all(12),
                    backgroundColor: colorScheme.primary,
                    foregroundColor: colorScheme.onPrimary,
                  ),

                  child: Icon(Iconsax.play, size: 28),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
--- END FILE: lib\features\deck_list\widgets\deck_list_item.dart ---


--- START FILE: lib\features\deck_management\screens\deck_edit_screen.dart ---
// lib/features/deck_management/screens/deck_edit_screen.dart

import 'package:ejd_cards/core/services/deck_persistence_service.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:iconsax_flutter/iconsax_flutter.dart';
import 'package:uuid/uuid.dart';
import '../../../core/models/card_model.dart';
import '../../../core/models/deck_model.dart';

class DeckEditScreen extends StatefulWidget {
  final DeckModel? initialDeck;

  const DeckEditScreen({super.key, this.initialDeck});

  @override
  State<DeckEditScreen> createState() => _DeckEditScreenState();
}

class _DeckEditScreenState extends State<DeckEditScreen> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _titleController;
  late TextEditingController _customFrontTimeController;
  late TextEditingController _customBackTimeController;
  late List<CardModel> _cards;
  late String _deckId;
  late DateTime _createdAt;

  bool _isNewDeck = false;
  final Uuid _uuid = const Uuid();
  final DeckPersistenceService _persistenceService = DeckPersistenceService();

  @override
  void initState() {
    super.initState();
    if (widget.initialDeck == null) {
      _isNewDeck = true;
      _deckId = _uuid.v4();
      _titleController = TextEditingController();
      _customFrontTimeController = TextEditingController();
      _customBackTimeController = TextEditingController();
      _cards = [];
      _createdAt = DateTime.now();
    } else {
      _isNewDeck = false;
      _deckId = widget.initialDeck!.id;
      _createdAt = widget.initialDeck!.createdAt;
      _titleController = TextEditingController(text: widget.initialDeck!.title);
      _customFrontTimeController = TextEditingController(text: widget.initialDeck!.customFrontTimeSeconds?.toString() ?? '');
      _customBackTimeController = TextEditingController(text: widget.initialDeck!.customBackTimeSeconds?.toString() ?? '');
      _cards = List<CardModel>.from(widget.initialDeck!.cards.map(
        (card) => CardModel(
          id: card.id,
          frontText: card.frontText,
          backText: card.backText,
          explanation: card.explanation,
          needsReview: card.needsReview,
        ),
      ));
    }
  }

  @override
  void dispose() {
    _titleController.dispose();
    _customFrontTimeController.dispose();
    _customBackTimeController.dispose();
    super.dispose();
  }

  Future<void> _saveDeck() async {
    if (_formKey.currentState!.validate()) {
      _formKey.currentState!.save();

      final int? customFrontTime = int.tryParse(_customFrontTimeController.text.trim());
      final int? customBackTime = int.tryParse(_customBackTimeController.text.trim());

      final updatedDeck = DeckModel(
        id: _deckId,
        title: _titleController.text.trim(),
        cards: _cards,
        createdAt: _createdAt,
        lastStudiedAt: widget.initialDeck?.lastStudiedAt,
        lastReviewedCardIndex: widget.initialDeck?.lastReviewedCardIndex,
        customFrontTimeSeconds: (customFrontTime != null && customFrontTime > 0) ? customFrontTime : null,
        customBackTimeSeconds: (customBackTime != null && customBackTime > 0) ? customBackTime : null,
      );

      await _persistenceService.saveDeck(updatedDeck);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Deck "${updatedDeck.title}" saved successfully!')),
        );
        Navigator.of(context).pop(true);
      }
    }
  }

  void _addOrEditCard({CardModel? existingCard, int? cardIndex}) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        final frontController = TextEditingController(text: existingCard?.frontText ?? '');
        final backController = TextEditingController(text: existingCard?.backText ?? '');
        final explanationController = TextEditingController(text: existingCard?.explanation ?? '');
        final cardFormKey = GlobalKey<FormState>();

        return AlertDialog(
          title: Text(existingCard == null ? 'Add New Card' : 'Edit Card'),
          content: SingleChildScrollView(
            child: Form(
              key: cardFormKey,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: <Widget>[
                  TextFormField(
                    controller: frontController,
                    decoration: const InputDecoration(labelText: 'Front Text (Question)'),
                    validator: (value) => (value == null || value.trim().isEmpty) ? 'Front text cannot be empty' : null,
                    maxLines: 3,
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: backController,
                    decoration: const InputDecoration(labelText: 'Back Text (Answer)'),
                    validator: (value) => (value == null || value.trim().isEmpty) ? 'Back text cannot be empty' : null,
                    maxLines: 3,
                  ),
                  const SizedBox(height: 16),
                  TextFormField(
                    controller: explanationController,
                    decoration: const InputDecoration(labelText: 'Explanation (Optional)'),
                    maxLines: 4,
                  ),
                ],
              ),
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: const Text('Cancel'),
              onPressed: () => Navigator.of(context).pop(),
            ),
            ElevatedButton(
              child: const Text('Save Card'),
              onPressed: () {
                if (cardFormKey.currentState!.validate()) {
                  setState(() {
                    final explanationText = explanationController.text.trim();
                    if (existingCard == null) {
                      _cards.add(CardModel(
                        id: _uuid.v4(),
                        frontText: frontController.text.trim(),
                        backText: backController.text.trim(),
                        explanation: explanationText.isEmpty ? null : explanationText,
                      ));
                    } else {
                      if (cardIndex != null) {
                        _cards[cardIndex] = CardModel(
                          id: existingCard.id,
                          frontText: frontController.text.trim(),
                          backText: backController.text.trim(),
                          explanation: explanationText.isEmpty ? null : explanationText,
                          needsReview: existingCard.needsReview,
                        );
                      }
                    }
                  });
                  Navigator.of(context).pop();
                }
              },
            ),
          ],
        );
      },
    );
  }

  void _deleteCard(int index) {
    if (index < 0 || index >= _cards.length) return;
    final cardToDelete = _cards[index];
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Delete Card?'),
        content: Text('Are you sure you want to delete this card?\nFront: "${cardToDelete.frontText}"'),
        actions: [
          TextButton(onPressed: () => Navigator.of(ctx).pop(), child: const Text('Cancel')),
          TextButton(
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            onPressed: () {
              setState(() {
                _cards.removeAt(index);
              });
              Navigator.of(ctx).pop();
            },
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(_isNewDeck ? 'Create New Deck' : 'Edit Deck'),
        leading: IconButton(
          icon: const Icon(Iconsax.close_circle),
          onPressed: () => Navigator.of(context).pop(false),
        ),
        actions: [
          IconButton(
            icon: const Icon(Iconsax.save_2),
            tooltip: 'Save Deck',
            onPressed: _saveDeck,
          ),
        ],
      ),
      body: Form(
        key: _formKey,
        child: Column(
          children: [
            // --- TOP NON-SCROLLING SECTION ---
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  TextFormField(
                    controller: _titleController,
                    decoration: const InputDecoration(
                      labelText: 'Deck Title',
                      border: OutlineInputBorder(),
                      hintText: 'Enter a title for your deck',
                    ),
                    validator: (value) => (value == null || value.trim().isEmpty) ? 'Deck title cannot be empty.' : null,
                  ),
                  const SizedBox(height: 24),
                  Text('Custom Autoplay Times (Optional)', style: Theme.of(context).textTheme.titleMedium),
                  const SizedBox(height: 8),
                  _buildCustomTimeRow(
                    label: 'Front Time (sec):',
                    controller: _customFrontTimeController,
                    hint: 'Global default',
                  ),
                  _buildCustomTimeRow(
                    label: 'Back Time (sec):',
                    controller: _customBackTimeController,
                    hint: 'Global default',
                  ),
                  const Divider(height: 32),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text('Cards (${_cards.length})', style: Theme.of(context).textTheme.titleMedium),
                      ElevatedButton.icon(
                        icon: const Icon(Iconsax.add_square),
                        label: const Text('Add Card'),
                        onPressed: () => _addOrEditCard(),
                      ),
                    ],
                  ),
                ],
              ),
            ),
            // --- SCROLLING CARD LIST ---
            Expanded(
              child: _cards.isEmpty
                  ? const Center(child: Text('No cards in this deck yet. Add one!'))
                  : ListView.builder(
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      itemCount: _cards.length,
                      itemBuilder: (context, index) {
                        final card = _cards[index];
                        return Card(
                          margin: const EdgeInsets.symmetric(vertical: 4.0),
                          child: ListTile(
                            leading: card.needsReview ? Tooltip(
                                    message: 'Marked for review',
                                    child: Icon(Iconsax.bookmark, color: Colors.orange[600]),
                                  ) : null,
                            title: Text(card.frontText, maxLines: 1, overflow: TextOverflow.ellipsis),
                            subtitle: Text(card.backText, maxLines: 1, overflow: TextOverflow.ellipsis),
                            trailing: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                IconButton(
                                  icon: const Icon(Iconsax.edit),
                                  onPressed: () => _addOrEditCard(existingCard: card, cardIndex: index),
                                ),
                                IconButton(
                                  icon: const Icon(Iconsax.trash, color: Colors.redAccent),
                                  onPressed: () => _deleteCard(index),
                                ),
                              ],
                            ),
                          ),
                        );
                      },
                    ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildCustomTimeRow({
    required String label,
    required TextEditingController controller,
    required String hint,
  }) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0),
      child: Row(
        children: [
          Expanded(flex: 3, child: Text(label)),
          Expanded(
            flex: 2,
            child: TextFormField(
              controller: controller,
              keyboardType: TextInputType.number,
              inputFormatters: [FilteringTextInputFormatter.digitsOnly],
              textAlign: TextAlign.center,
              decoration: InputDecoration(
                border: const OutlineInputBorder(),
                hintText: hint,
                isDense: true,
              ),
              validator: (value) {
                if (value == null || value.trim().isEmpty) return null;
                final num = int.tryParse(value.trim());
                if (num == null || num <= 0) return 'Must be >0';
                return null;
              },
            ),
          ),
        ],
      ),
    );
  }
}
--- END FILE: lib\features\deck_management\screens\deck_edit_screen.dart ---


--- START FILE: lib\features\deck_management\services\deck_exporter_service.dart ---
// lib/features/deck_management/services/deck_exporter_service.dart

import 'dart:convert';
import 'package:file_saver/file_saver.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:share_plus/share_plus.dart';
import '../../../core/models/deck_model.dart';

class DeckExporterService {
  Future<String?> exportDeck(DeckModel deck) async {
    try {
      // Prepare the data for export. We only export the core content.
      final Map<String, dynamic> exportData = {
        'title': deck.title,
        'cards': deck.cards.map((card) => {
              'frontText': card.frontText,
              'backText': card.backText,
              'explanation': card.explanation,
            }).toList(),
      };

      // Use a pretty-printed JSON for better human readability
      final jsonString = const JsonEncoder.withIndent('  ').convert(exportData);
      final bytes = utf8.encode(jsonString);

      // Sanitize the filename to remove invalid characters
      final sanitizedTitle = deck.title.replaceAll(RegExp(r'[^\w\s-]'), '').replaceAll(' ', '_');
      final fileName = 'EJD_Cards_${sanitizedTitle}.json';

      if (kIsWeb) {
        // On web, file_saver downloads the file directly to the user's machine.
        await FileSaver.instance.saveFile(
          name: fileName,
          bytes: bytes,
          ext: 'json',
          mimeType: MimeType.json,
        );
        return "Deck downloaded as $fileName";
      } else {
        // On mobile/desktop, use the share_plus package to open the native share sheet.
        // This gives the user the option to save to files, send via email, airdrop, etc.
        final xfile = XFile.fromData(
          bytes,
          mimeType: 'application/json',
          name: fileName,
        );
        await Share.shareXFiles([xfile], subject: 'EJD Cards Deck: ${deck.title}');
        return null; // Don't show a snackbar on success, as the share sheet is the feedback.
      }
    } catch (e) {
      print("Error exporting deck: $e");
      return "Failed to export deck. Error: $e";
    }
  }
}
--- END FILE: lib\features\deck_management\services\deck_exporter_service.dart ---


--- START FILE: lib\features\deck_management\services\deck_importer_service.dart ---
// lib/features/deck_management/services/deck_importer_service.dart

import 'dart:convert';
import 'dart:typed_data';
import 'package:uuid/uuid.dart';
import '../../../core/models/deck_model.dart';
import '../../../core/models/card_model.dart';

class DeckImporterService {
  final Uuid _uuid = const Uuid();

  Future<ParseResult> importDeckFromFile(Uint8List fileBytes) async {
    try {
      final String content = utf8.decode(fileBytes);
      final Map<String, dynamic> jsonMap = jsonDecode(content);

      // Validate top-level keys
      if (!jsonMap.containsKey('title') || !jsonMap.containsKey('cards')) {
        return ParseResult(error: "JSON file is missing 'title' or 'cards' field.");
      }

      final String title = jsonMap['title'];
      final List<dynamic> cardMaps = jsonMap['cards'];

      if (title.trim().isEmpty) {
        return ParseResult(error: "Deck 'title' in JSON cannot be empty.");
      }

      // Create a new DeckModel from the parsed data.
      // We generate new IDs for the imported deck and cards to avoid conflicts.
      final newDeck = DeckModel(
        id: _uuid.v4(),
        title: title,
        cards: cardMaps.map((cardMap) {
          return CardModel(
            id: _uuid.v4(),
            frontText: cardMap['frontText'] ?? '',
            backText: cardMap['backText'] ?? '',
            explanation: cardMap['explanation'],
            // needsReview is intentionally not imported, as it's user-specific progress
            needsReview: false,
          );
        }).toList(),
        createdAt: DateTime.now(),
      );

      return ParseResult(deck: newDeck);
    } catch (e) {
      return ParseResult(error: "Failed to parse JSON file. Error: ${e.toString()}");
    }
  }

  // New method to handle a raw string
  Future<ParseResult> importDeckFromString(String jsonString) async {
    try {
      // Convert the string to bytes and call the existing method
      final bytes = Uint8List.fromList(utf8.encode(jsonString));
      return await importDeckFromFile(bytes);
    } catch (e) {
      return ParseResult(error: "Invalid text format. Error: ${e.toString()}");
    }
  }

  
}

class ParseResult {
  final DeckModel? deck;
  final String? error;

  ParseResult({this.deck, this.error});

  bool get hasError => error != null;
}
--- END FILE: lib\features\deck_management\services\deck_importer_service.dart ---


--- START FILE: lib\features\settings\screens\about_page.dart ---
// lib/features/settings/screens/about_page.dart

import 'package:flutter/material.dart';
import 'package:iconsax_flutter/iconsax_flutter.dart';
import 'package:package_info_plus/package_info_plus.dart';
import '../../../core/services/deck_persistence_service.dart';
import '../../../core/services/settings_service.dart';
import '../../../main.dart'; // To reset themeNotifier and get AppThemeMode

class AboutPage extends StatefulWidget {
  const AboutPage({super.key});

  @override
  State<AboutPage> createState() => _AboutPageState();
}

class _AboutPageState extends State<AboutPage> {
  String _version = '...';

  @override
  void initState() {
    super.initState();
    _loadVersionInfo();
  }

  Future<void> _loadVersionInfo() async {
    final packageInfo = await PackageInfo.fromPlatform();
    if (mounted) {
      setState(() {
        _version = '${packageInfo.version} (Build ${packageInfo.buildNumber})';
      });
    }
  }

  void _showResetConfirmationDialog() {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Reset All App Data?'),
        content: const Text('This action is irreversible. All your decks and settings will be permanently deleted.'),
        actions: [
          TextButton(onPressed: () => Navigator.of(ctx).pop(), child: const Text('Cancel')),
          TextButton(
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            onPressed: () async {
              // Perform the reset
              await DeckPersistenceService().deleteAllDecks();

              final settings = SettingsService();
              await settings.setThemeMode(AppThemeMode.system);
              await settings.setDefaultFrontTime(SettingsService.defaultFrontSeconds);
              await settings.setDefaultBackTime(SettingsService.defaultBackSeconds);
              await settings.setAutoplayShuffle(SettingsService.defaultShuffle);
              await settings.setAutoplayLoop(SettingsService.defaultLoop);

              // Update the global notifier to reflect the theme reset instantly
              themeNotifier.value = AppThemeMode.system;

              // Close the dialog
              if (mounted) Navigator.of(ctx).pop();

              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('App data has been reset.')),
                );
                // Pop all the way back to the deck list, which will then be forced to refresh
                Navigator.of(context).popUntil((route) => route.isFirst);
              }
            },
            child: const Text('Reset Data'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('About & Data'),
      ),
      body: ListView(
        padding: const EdgeInsets.all(16.0),
        children: [
          ListTile(
            leading: const Icon(Iconsax.document_code),
            title: const Text('App Version'),
            subtitle: Text(_version),
          ),
          const Divider(),
          const ListTile(
            leading: Icon(Iconsax.code),
            title: Text('Framework'),
            subtitle: Text('Built with Flutter'),
          ),
          const Divider(),
          const SizedBox(height: 32),
          Center(
            child: OutlinedButton.icon(
              icon: const Icon(Iconsax.trash, size: 20),
              label: const Text('Reset All App Data'),
              style: OutlinedButton.styleFrom(
                foregroundColor: Colors.red,
                side: const BorderSide(color: Colors.red),
              ),
              onPressed: _showResetConfirmationDialog,
            ),
          ),
        ],
      ),
    );
  }
}
--- END FILE: lib\features\settings\screens\about_page.dart ---


--- START FILE: lib\features\settings\screens\settings_screen.dart ---
// lib/features/settings/screens/settings_screen.dart

import 'package:ejd_cards/features/settings/screens/about_page.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:iconsax_flutter/iconsax_flutter.dart';
import '../../../core/services/settings_service.dart';
import '../../../main.dart'; // To access AppThemeMode and themeNotifier

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  final SettingsService _settingsService = SettingsService();
  late int _defaultFrontTime;
  late int _defaultBackTime;
  late bool _autoplayShuffle;
  late bool _autoplayLoop;
  bool _isLoading = true;

  final _frontTimeController = TextEditingController();
  final _backTimeController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _loadSettings();
  }

  Future<void> _loadSettings() async {
    if (!mounted) return;
    setState(() {
      _isLoading = true;
    });
    _defaultFrontTime = await _settingsService.getDefaultFrontTime();
    _defaultBackTime = await _settingsService.getDefaultBackTime();
    _autoplayShuffle = await _settingsService.getAutoplayShuffle();
    _autoplayLoop = await _settingsService.getAutoplayLoop();

    _frontTimeController.text = _defaultFrontTime.toString();
    _backTimeController.text = _defaultBackTime.toString();

    if (mounted) {
      setState(() {
        _isLoading = false;
      });
    }
  }

  @override
  void dispose() {
    _frontTimeController.dispose();
    _backTimeController.dispose();
    super.dispose();
  }

  Future<void> _saveDefaultFrontTime() async {
    final newTime = int.tryParse(_frontTimeController.text);
    if (newTime != null && newTime > 0) {
      await _settingsService.setDefaultFrontTime(newTime);
      if (mounted) {
        setState(() {
          _defaultFrontTime = newTime;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Default front time saved!')),
        );
      }
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Invalid time. Please enter a positive number.')),
      );
      _frontTimeController.text = _defaultFrontTime.toString();
    }
  }

  Future<void> _saveDefaultBackTime() async {
    final newTime = int.tryParse(_backTimeController.text);
    if (newTime != null && newTime > 0) {
      await _settingsService.setDefaultBackTime(newTime);
      if (mounted) {
        setState(() {
          _defaultBackTime = newTime;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Default back time saved!')),
        );
      }
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Invalid time. Please enter a positive number.')),
      );
      _backTimeController.text = _defaultBackTime.toString();
    }
  }

  Future<void> _saveAutoplayShuffle(bool value) async {
    await _settingsService.setAutoplayShuffle(value);
    if (mounted) {
      setState(() {
        _autoplayShuffle = value;
      });
    }
  }

  Future<void> _saveAutoplayLoop(bool value) async {
    await _settingsService.setAutoplayLoop(value);
    if (mounted) {
      setState(() {
        _autoplayLoop = value;
      });
    }
  }

  Future<void> _changeTheme(AppThemeMode? newMode) async {
    if (newMode == null) return;
    themeNotifier.value = newMode;
    await _settingsService.setThemeMode(newMode);
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return Scaffold(
        appBar: AppBar(title: const Text('Settings')),
        body: const Center(child: CircularProgressIndicator()),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Settings'),
      ),
      body: ListView(
        padding: const EdgeInsets.all(16.0),
        children: <Widget>[
          Text('Appearance', style: Theme.of(context).textTheme.titleLarge),
          ListTile(
            contentPadding: const EdgeInsets.symmetric(horizontal: 4),
            leading: const Icon(Iconsax.brush_1),
            title: const Text('Theme'),
            trailing: DropdownButton<AppThemeMode>(
              value: themeNotifier.value,
              items: const [
                DropdownMenuItem(value: AppThemeMode.system, child: Text('System Default')),
                DropdownMenuItem(value: AppThemeMode.light, child: Text('Light')),
                DropdownMenuItem(value: AppThemeMode.dark, child: Text('Dark (Grey)')),
                DropdownMenuItem(value: AppThemeMode.amoled, child: Text('Dark (AMOLED)')),
              ],
              onChanged: _changeTheme,
            ),
          ),
          const Divider(height: 40),
          Text('Autoplay Defaults', style: Theme.of(context).textTheme.titleLarge),
          const SizedBox(height: 16),
          _buildTimeSettingRow(
            label: 'Front Display Time (seconds):',
            controller: _frontTimeController,
            onSave: _saveDefaultFrontTime,
          ),
          const SizedBox(height: 16),
          _buildTimeSettingRow(
            label: 'Back Display Time (seconds):',
            controller: _backTimeController,
            onSave: _saveDefaultBackTime,
          ),
          const SizedBox(height: 24),
          SwitchListTile(
            contentPadding: const EdgeInsets.symmetric(horizontal: 4),
            title: const Text('Shuffle Cards by Default'),
            value: _autoplayShuffle,
            onChanged: _saveAutoplayShuffle,
            secondary: const Icon(Iconsax.shuffle),
          ),
          SwitchListTile(
            contentPadding: const EdgeInsets.symmetric(horizontal: 4),
            title: const Text('Loop Deck by Default'),
            subtitle: const Text('Restart deck automatically when finished.'),
            value: _autoplayLoop,
            onChanged: _saveAutoplayLoop,
            secondary: const Icon(Iconsax.repeat),
          ),
          const Divider(height: 40),
          ListTile(
            contentPadding: const EdgeInsets.symmetric(horizontal: 4),
            leading: const Icon(Iconsax.info_circle),
            title: const Text('About & Data Management'),
            onTap: () {
              Navigator.of(context).push(MaterialPageRoute(builder: (ctx) => const AboutPage()));
            },
          ),
        ],
      ),
    );
  }

  Widget _buildTimeSettingRow({
    required String label,
    required TextEditingController controller,
    required VoidCallback onSave,
  }) {
    return Row(
      children: [
        Expanded(child: Text(label)),
        const SizedBox(width: 10),
        SizedBox(
          width: 70,
          child: TextFormField(
            controller: controller,
            keyboardType: TextInputType.number,
            inputFormatters: [FilteringTextInputFormatter.digitsOnly],
            textAlign: TextAlign.center,
            decoration: const InputDecoration(border: OutlineInputBorder()),
            validator: (value) {
              if (value == null || value.trim().isEmpty) return null;
              final num = int.tryParse(value.trim());
              if (num == null || num <= 0) return 'Must be >0';
              return null;
            },
          ),
        ),
        const SizedBox(width: 10),
        IconButton(
          icon: const Icon(Iconsax.save_2),
          tooltip: 'Save Time',
          onPressed: onSave,
          color: Theme.of(context).primaryColor,
        ),
      ],
    );
  }
}
--- END FILE: lib\features\settings\screens\settings_screen.dart ---


--- START FILE: lib\features\study_mode\screens\autoplay_screen.dart ---
// lib/features/study_mode/screens/autoplay_screen.dart

import 'dart:async';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:iconsax_flutter/iconsax_flutter.dart';
import 'package:wakelock_plus/wakelock_plus.dart';
import '../../../core/models/card_model.dart';
import '../../../core/models/deck_model.dart';
import '../../../core/services/deck_persistence_service.dart';
import '../../../core/services/settings_service.dart';
import '../../../core/widgets/flip_card_widget.dart';

enum AutoplayStatus { playing, paused, stopped, finished }

class AutoplayScreen extends StatefulWidget {
  final DeckModel deck;
  final int startIndex;

  const AutoplayScreen({
    super.key,
    required this.deck,
    this.startIndex = 0,
  });

  @override
  State<AutoplayScreen> createState() => _AutoplayScreenState();
}

class _AutoplayScreenState extends State<AutoplayScreen> with SingleTickerProviderStateMixin {
  int _currentIndex = 0;
  bool _showFront = true;
  AutoplayStatus _status = AutoplayStatus.stopped;
  Timer? _transitionDelayTimer;

  // New AnimationController for smooth progress bar
  late AnimationController _progressController;

  final SettingsService _settingsService = SettingsService();
  final DeckPersistenceService _persistenceService = DeckPersistenceService();
  final FlipCardController _flipCardController = FlipCardController();
  final Random _random = Random();

  late int _globalFrontTime;
  late int _globalBackTime;
  late bool _shouldShuffle;
  late bool _shouldLoop;
  bool _isLoadingSettings = true;

  List<CardModel> _currentPlayList = [];

  @override
  void initState() {
    super.initState();
    _progressController = AnimationController(vsync: this)..addListener(() => setState(() {}));
    WakelockPlus.enable();
    _loadSettingsAndPrepareDeck();
  }

  Future<void> _loadSettingsAndPrepareDeck() async {
    // ... (This method remains the same as the last version)
    if (!mounted) return;
    setState(() => _isLoadingSettings = true);

    _globalFrontTime = await _settingsService.getDefaultFrontTime();
    _globalBackTime = await _settingsService.getDefaultBackTime();
    _shouldShuffle = await _settingsService.getAutoplayShuffle();
    _shouldLoop = await _settingsService.getAutoplayLoop();

    if (widget.startIndex > 0) _shouldShuffle = false;

    _preparePlayList();
    _currentIndex = (widget.startIndex < _currentPlayList.length) ? widget.startIndex : 0;

    if (mounted) {
      setState(() => _isLoadingSettings = false);
      if (_currentPlayList.isNotEmpty) {
        _status = AutoplayStatus.playing;
        _startCardCycle();
      } else {
        _status = AutoplayStatus.finished;
      }
    }
  }

  void _preparePlayList() {
    _currentPlayList = List<CardModel>.from(widget.deck.cards);
    if (_shouldShuffle && _currentPlayList.isNotEmpty) {
      _currentPlayList.shuffle(_random);
    }
    _currentIndex = 0;
  }

  @override
  void dispose() {
    WakelockPlus.disable();
    _progressController.dispose();
    _transitionDelayTimer?.cancel();
    super.dispose();
  }

  CardModel? get _currentCard => (_currentPlayList.isEmpty || _currentIndex >= _currentPlayList.length) ? null : _currentPlayList[_currentIndex];
  int get _frontDuration => widget.deck.customFrontTimeSeconds ?? _globalFrontTime;
  int get _backDuration => widget.deck.customBackTimeSeconds ?? _globalBackTime;

  void _startCardCycle() {
    if (_status != AutoplayStatus.playing || _currentCard == null) return;
    _transitionDelayTimer?.cancel();
    _flipCardController.reset();

    if (!mounted) return;
    setState(() => _showFront = true);

    _progressController.duration = Duration(seconds: _frontDuration);
    _progressController.forward(from: 0.0).whenComplete(() {
      if (_status == AutoplayStatus.playing) _showBackSide();
    });
  }

  void _showBackSide() {
    if (!mounted || _status != AutoplayStatus.playing || _currentCard == null) return;
    _flipCardController.flip();
    setState(() => _showFront = false);

    _progressController.duration = Duration(seconds: _backDuration);
    _progressController.forward(from: 0.0).whenComplete(() {
      if (_status == AutoplayStatus.playing) {
        _transitionDelayTimer = Timer(const Duration(milliseconds: 500), _moveToNextCard);
      }
    });
  }

  void _moveToNextCard() {
    if (!mounted || _status != AutoplayStatus.playing) return;
    if (_currentIndex < _currentPlayList.length - 1) {
      setState(() => _currentIndex++);
      _startCardCycle();
    } else {
      if (_shouldLoop) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Looping deck...")));
        _preparePlayList();
        if (_currentPlayList.isNotEmpty) _startCardCycle();
        else if (mounted) setState(() => _status = AutoplayStatus.finished);
      } else {
        if (mounted) setState(() => _status = AutoplayStatus.finished);
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Autoplay finished: End of deck reached.")));
      }
    }
  }

  void _togglePlayPause() {
    if (_isLoadingSettings) return;
    if (_status == AutoplayStatus.playing) {
      setState(() => _status = AutoplayStatus.paused);
      _progressController.stop();
    } else if (_status == AutoplayStatus.paused) {
      setState(() => _status = AutoplayStatus.playing);
      _progressController.forward();
    } else if (_status == AutoplayStatus.finished && _currentPlayList.isNotEmpty) {
      _preparePlayList();
      setState(() => _status = AutoplayStatus.playing);
      _startCardCycle();
    }
  }

  Future<void> _stopAutoplay() async {
    final bool wasFinished = _status == AutoplayStatus.finished;
    final int indexToSave = (wasFinished || _currentCard == null) ? 0 : _currentIndex;
    widget.deck.lastReviewedCardIndex = indexToSave;
    widget.deck.lastStudiedAt = DateTime.now();
    await _persistenceService.saveDeck(widget.deck);

    if (mounted) setState(() => _status = AutoplayStatus.stopped);
    _progressController.stop();
    _transitionDelayTimer?.cancel();
    if (mounted) Navigator.of(context).pop(true);
  }

  void _toggleSessionShuffle(bool value) {
    if (!mounted) return;
    setState(() => _shouldShuffle = value);
    _preparePlayList();
    if ((_status == AutoplayStatus.playing || _status == AutoplayStatus.paused) && _currentPlayList.isNotEmpty) {
      if(_status == AutoplayStatus.paused) setState(() => _status = AutoplayStatus.playing);
      _startCardCycle();
    } else if (_currentPlayList.isEmpty) {
      setState(() => _status = AutoplayStatus.finished);
    }
  }

  void _toggleSessionLoop(bool value) {
    if (!mounted) setState(() => _shouldLoop = value);
  }

  void _showExplanationDialog() {
    if (_currentCard?.explanation == null) return;
    if (_status == AutoplayStatus.playing) _togglePlayPause();
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Explanation'),
        content: SingleChildScrollView(child: Text(_currentCard!.explanation!)),
        actions: [TextButton(child: const Text('Close'), onPressed: () => Navigator.of(ctx).pop())],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoadingSettings) {
      return Scaffold(appBar: AppBar(title: Text('Autoplay: ${widget.deck.title}')), body: const Center(child: CircularProgressIndicator()));
    }

    final card = _currentCard;
    final theme = Theme.of(context);
    final cardContentStyle = theme.textTheme.displaySmall?.copyWith(fontSize: 32);

    final frontWidget = Text(card?.frontText ?? (_currentPlayList.isEmpty ? "No cards to play." : "Autoplay Finished!"), textAlign: TextAlign.center, style: cardContentStyle);
    final backWidget = Text(card?.backText ?? "---", textAlign: TextAlign.center, style: cardContentStyle);
    final bool canPlayPause = _status == AutoplayStatus.playing || _status == AutoplayStatus.paused || (_status == AutoplayStatus.finished && _currentPlayList.isNotEmpty);
    final bool shuffleToggleEnabled = _status == AutoplayStatus.playing || _status == AutoplayStatus.paused || (_status == AutoplayStatus.finished && _currentPlayList.isNotEmpty);
    final bool isOriginalDeckEmpty = widget.deck.cards.isEmpty;


    return Scaffold(
      appBar: AppBar(title: Text('Autoplay: ${widget.deck.title}'), leading: IconButton(icon: const Icon(Iconsax.close_circle), onPressed: _stopAutoplay)),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            if (_currentPlayList.isNotEmpty && _status != AutoplayStatus.finished && _status != AutoplayStatus.stopped)
              Padding(padding: const EdgeInsets.symmetric(vertical: 8.0), child: Text('Card ${_currentIndex + 1} of ${_currentPlayList.length}', textAlign: TextAlign.center, style: theme.textTheme.titleMedium)),
            Expanded(child: FlipCardWidget(controller: _flipCardController, front: frontWidget, back: backWidget)),
            const SizedBox(height: 10),
            if (!_showFront && _currentCard?.explanation != null && _status != AutoplayStatus.finished)
              Padding(padding: const EdgeInsets.only(bottom: 8.0), child: TextButton.icon(icon: const Icon(Iconsax.document_text_1), label: const Text('Why? Show Explanation'), onPressed: _showExplanationDialog)),
            
            // --- NEW SMOOTH PROGRESS BAR ---
            if (_status == AutoplayStatus.playing || _status == AutoplayStatus.paused)
              LinearProgressIndicator(
                value: _progressController.value,
                minHeight: 10,
                backgroundColor: Colors.grey[300],
                valueColor: AlwaysStoppedAnimation<Color>(_showFront ? theme.primaryColor : Colors.green),
              ),
            
            if (_status == AutoplayStatus.paused && card != null)
              const Padding(padding: EdgeInsets.symmetric(vertical: 8.0), child: Text("Paused", textAlign: TextAlign.center, style: TextStyle(fontStyle: FontStyle.italic))),
            const SizedBox(height: 10),
            Padding(padding: const EdgeInsets.symmetric(horizontal: 8.0), child: Row(mainAxisAlignment: MainAxisAlignment.spaceAround, children: [Flexible(child: Column(mainAxisSize: MainAxisSize.min, children: [const Text("Shuffle"), Switch(value: _shouldShuffle, onChanged: isOriginalDeckEmpty ? null : (shuffleToggleEnabled ? _toggleSessionShuffle : null))])), Flexible(child: Column(mainAxisSize: MainAxisSize.min, children: [const Text("Loop Deck"), Switch(value: _shouldLoop, onChanged: isOriginalDeckEmpty ? null : _toggleSessionLoop)]))])),
            const SizedBox(height: 20),
            Row(mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [IconButton(icon: Icon(_status == AutoplayStatus.playing ? Iconsax.pause_circle : Iconsax.play_circle, size: 60), color: theme.primaryColor, onPressed: isOriginalDeckEmpty ? null : (canPlayPause ? _togglePlayPause : null), tooltip: _status == AutoplayStatus.playing ? "Pause" : "Play/Restart")]),
            const SizedBox(height: 20),
            OutlinedButton.icon(icon: const Icon(Iconsax.stop_circle, size: 20), label: const Text('Stop Autoplay & Go Back'), style: OutlinedButton.styleFrom(foregroundColor: Colors.red, side: const BorderSide(color: Colors.red)), onPressed: _stopAutoplay),
          ],
        ),
      ),
    );
  }
}
--- END FILE: lib\features\study_mode\screens\autoplay_screen.dart ---


--- START FILE: lib\features\study_mode\screens\manual_study_screen.dart ---
// lib/features/study_mode/screens/manual_study_screen.dart

import 'dart:math';
import 'package:ejd_cards/core/models/card_model.dart';
import 'package:ejd_cards/core/models/deck_model.dart';
import 'package:ejd_cards/core/services/deck_persistence_service.dart';
import 'package:ejd_cards/core/widgets/flip_card_widget.dart';
import 'package:flutter/material.dart';
import 'package:iconsax_flutter/iconsax_flutter.dart';

class ManualStudyScreen extends StatefulWidget {
  final DeckModel deck;

  const ManualStudyScreen({super.key, required this.deck});

  @override
  State<ManualStudyScreen> createState() => _ManualStudyScreenState();
}

class _ManualStudyScreenState extends State<ManualStudyScreen> {
  int _currentIndex = 0;
  bool _showFront = true;
  bool _isShuffled = false;
  List<CardModel> _studyOrderCards = [];

  final Random _random = Random();
  final FlipCardController _flipCardController = FlipCardController();
  final DeckPersistenceService _persistenceService = DeckPersistenceService();

  @override
  void initState() {
    super.initState();
    _resetStudyOrder();
  }

  void _resetStudyOrder() {
    setState(() {
      _studyOrderCards = List<CardModel>.from(widget.deck.cards);
      if (_isShuffled && _studyOrderCards.isNotEmpty) {
        _studyOrderCards.shuffle(_random);
      }
      _currentIndex = 0;
      _showFront = true;
      _flipCardController.reset();
    });
  }

  void _toggleShuffle() {
    setState(() {
      _isShuffled = !_isShuffled;
    });
    _resetStudyOrder();
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(_isShuffled ? 'Cards shuffled!' : 'Cards in original order.')),
    );
  }

  CardModel? get _currentCard => (_studyOrderCards.isEmpty || _currentIndex >= _studyOrderCards.length) ? null : _studyOrderCards[_currentIndex];

  void _flipCard() {
    if (_currentCard == null) return;
    _flipCardController.flip();
    setState(() {
      _showFront = !_showFront;
    });
  }

  void _nextCard() {
    if (_currentCard == null) return;
    if (_currentIndex < _studyOrderCards.length - 1) {
      setState(() {
        _currentIndex++;
        _showFront = true;
      });
      _flipCardController.reset();
    } else {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("You've reached the end of the deck!")));
    }
  }

  void _previousCard() {
    if (_currentCard == null) return;
    if (_currentIndex > 0) {
      setState(() {
        _currentIndex--;
        _showFront = true;
      });
      _flipCardController.reset();
    } else {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("You're at the beginning of the deck.")));
    }
  }

  Future<void> _markCardAs(bool needsReview) async {
    if (_currentCard == null) return;
    setState(() {
      _currentCard!.needsReview = needsReview;
    });

    final originalCardIndex = widget.deck.cards.indexWhere((card) => card.id == _currentCard!.id);
    if (originalCardIndex != -1) {
      widget.deck.cards[originalCardIndex].needsReview = needsReview;
    }

    await _persistenceService.saveDeck(widget.deck);
    _nextCard();
  }

  void _showExplanationDialog() {
    if (_currentCard?.explanation == null) return;
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Explanation'),
        content: SingleChildScrollView(child: Text(_currentCard!.explanation!)),
        actions: [TextButton(child: const Text('Close'), onPressed: () => Navigator.of(ctx).pop())],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final card = _currentCard;
    final theme = Theme.of(context);
    final cardContentStyle = theme.textTheme.displaySmall?.copyWith(fontSize: 32);

    final frontWidget = Text(card?.frontText ?? "This deck is empty.", textAlign: TextAlign.center, style: cardContentStyle);
    final backWidget = Text(card?.backText ?? "Add cards to study.", textAlign: TextAlign.center, style: cardContentStyle);

    return Scaffold(
      appBar: AppBar(
        title: Text('Study: ${widget.deck.title}'),
        actions: [
          Tooltip(
            message: _isShuffled ? "Unshuffle Cards" : "Shuffle Cards",
            child: IconButton(
              icon: Icon(_isShuffled ? Iconsax.shuffle : Iconsax.shuffle),
              onPressed: widget.deck.cards.length > 1 ? _toggleShuffle : null,
            ),
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            if (_studyOrderCards.isNotEmpty)
              Padding(
                padding: const EdgeInsets.symmetric(vertical: 8.0),
                child: Text('Card ${_currentIndex + 1} of ${_studyOrderCards.length}', textAlign: TextAlign.center, style: theme.textTheme.titleMedium),
              ),
            Expanded(
              child: GestureDetector(
                onTap: card != null ? _flipCard : null,
                child: FlipCardWidget(controller: _flipCardController, front: frontWidget, back: backWidget),
              ),
            ),
            const SizedBox(height: 20),
            if (card != null)
              _showFront
                  ? ElevatedButton.icon(
                      icon: const Icon(Iconsax.eye),
                      label: const Text('Show Answer'),
                      onPressed: _flipCard,
                      style: ElevatedButton.styleFrom(minimumSize: const Size(double.infinity, 50)),
                    )
                  : Column(
                      children: [
                        if (card.explanation != null)
                          Padding(
                            padding: const EdgeInsets.only(bottom: 10.0),
                            child: TextButton.icon(
                              icon: const Icon(Iconsax.document_text_1),
                              label: const Text('Why? Show Explanation'),
                              onPressed: _showExplanationDialog,
                            ),
                          ),
                        Row(
                          children: [
                            Expanded(
                              child: ElevatedButton.icon(
                                icon: const Icon(Iconsax.dislike, color: Colors.white),
                                label: const Text('Review Again'),
                                onPressed: () => _markCardAs(true),
                                style: ElevatedButton.styleFrom(backgroundColor: Colors.orange, minimumSize: const Size(0, 50)),
                              ),
                            ),
                            const SizedBox(width: 10),
                            Expanded(
                              child: ElevatedButton.icon(
                                icon: const Icon(Iconsax.like_1, color: Colors.white),
                                label: const Text('I Knew This'),
                                onPressed: () => _markCardAs(false),
                                style: ElevatedButton.styleFrom(backgroundColor: Colors.green, minimumSize: const Size(0, 50)),
                              ),
                            )
                          ],
                        ),
                      ],
                    ),
            const SizedBox(height: 10),
            if (card != null)
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Expanded(
                    child: OutlinedButton.icon(
                      icon: const Icon(Iconsax.arrow_left_2),
                      label: const Text('Previous'),
                      onPressed: _currentIndex > 0 ? _previousCard : null,
                      style: OutlinedButton.styleFrom(minimumSize: const Size(0, 50)),
                    ),
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    child: OutlinedButton.icon(
                      label: const Text('Next'),
                      icon: const Icon(Iconsax.arrow_right_3),
                      onPressed: _currentIndex < _studyOrderCards.length - 1 ? _nextCard : null,
                      style: OutlinedButton.styleFrom(minimumSize: const Size(0, 50)),
                    ),
                  ),
                ],
              ),
            const SizedBox(height: 10),
          ],
        ),
      ),
    );
  }
}
--- END FILE: lib\features\study_mode\screens\manual_study_screen.dart ---


--- START FILE: lib\main.dart ---
// lib/main.dart
import 'package:flutter/material.dart';
import 'package:ejd_cards/features/deck_list/screens/deck_list_screen.dart';
import 'package:ejd_cards/core/services/settings_service.dart';
import 'package:ejd_cards/core/theme/app_theme.dart'; // Import our new theme file

// We now need a custom enum for our theme setting
enum AppThemeMode { system, light, dark, amoled }

final ValueNotifier<AppThemeMode> themeNotifier = ValueNotifier(AppThemeMode.system);

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  final settingsService = SettingsService();
  themeNotifier.value = await settingsService.getThemeMode();
  runApp(const EjdCardsApp());
}

class EjdCardsApp extends StatelessWidget {
  const EjdCardsApp({super.key});

  @override
  Widget build(BuildContext context) {
    return ValueListenableBuilder<AppThemeMode>(
      valueListenable: themeNotifier,
      builder: (context, currentMode, child) {
        final brightness = MediaQuery.platformBrightnessOf(context);
        final useDarkTheme = (currentMode == AppThemeMode.dark) ||
                             (currentMode == AppThemeMode.amoled) ||
                             (currentMode == AppThemeMode.system && brightness == Brightness.dark);

        return MaterialApp(
          title: 'EJD Cards',
          debugShowCheckedModeBanner: false,
          theme: AppTheme.lightTheme,
          darkTheme: (currentMode == AppThemeMode.amoled || (currentMode == AppThemeMode.system && useDarkTheme))
              ? AppTheme.amoledTheme
              : AppTheme.darkTheme,
          themeMode: useDarkTheme ? ThemeMode.dark : ThemeMode.light,
          home: const DeckListScreen(),
        );
      },
    );
  }
}
--- END FILE: lib\main.dart ---


--- START FILE: pubspec.yaml ---
name: ejd_cards
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.8.1

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  uuid: ^4.4.2
  file_picker: ^10.1.9
  path_provider: ^2.1.5
  shared_preferences: ^2.5.3 
  package_info_plus: ^8.3.0
  file_saver: ^0.2.14
  share_plus: ^11.0.0
  google_fonts: ^4.0.3
  iconsax_flutter: ^1.0.1
  flutter_animate: ^4.5.2
  wakelock_plus: ^1.3.2

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^6.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package

--- END FILE: pubspec.yaml ---


